package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	
	"gopkg.in/yaml.v3"
)

// HTMLSpec represents the structure of the HTML specification YAML
type HTMLSpec struct {
	Version           string              `yaml:"version"`
	Generated         string              `yaml:"generated"`
	Source            string              `yaml:"source"`
	GlobalAttributes  []AttributeDef      `yaml:"global_attributes"`
	EventHandlers     []string            `yaml:"event_handlers"`
	Elements          map[string][]ElementDef `yaml:"elements"`
	Generation        GenerationConfig    `yaml:"generation"`
	SkipElements      []string            `yaml:"skip_elements"`
}

// AttributeDef defines an HTML attribute
type AttributeDef struct {
	Name   string   `yaml:"name"`
	Type   string   `yaml:"type"`
	Alias  string   `yaml:"alias,omitempty"`
	Values []string `yaml:"values,omitempty"`
}

// ElementDef defines an HTML element
type ElementDef struct {
	Tag                string         `yaml:"tag"`
	Void               bool           `yaml:"void"`
	TextOnly           bool           `yaml:"text_only,omitempty"`
	Attributes         []AttributeDef `yaml:"attributes,omitempty"`
	AllowedChildren    []string       `yaml:"allowed_children,omitempty"`
	ParentRequired     []string       `yaml:"parent_required,omitempty"`
	PreserveWhitespace bool           `yaml:"preserve_whitespace,omitempty"`
	Unique             bool           `yaml:"unique,omitempty"`
	SemanticLevel      int            `yaml:"semantic_level,omitempty"`
	Namespace          string         `yaml:"namespace,omitempty"`
}

// GenerationConfig defines code generation settings
type GenerationConfig struct {
	Layer0 OutputConfig `yaml:"layer0"`
	Layer1 OutputConfig `yaml:"layer1"`
	Props  OutputConfig `yaml:"props"`
	Tests  OutputConfig `yaml:"tests"`
}

// OutputConfig defines output settings for generated code
type OutputConfig struct {
	Package string `yaml:"package"`
	Output  string `yaml:"output"`
}

// BuilderGenerator generates the fluent builder API
type BuilderGenerator struct {
	spec *HTMLSpec
}

// NewBuilderGenerator creates a new builder generator
func NewBuilderGenerator(specPath string) (*BuilderGenerator, error) {
	// Read spec file
	data, err := os.ReadFile(specPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read spec file: %w", err)
	}
	
	// Parse YAML
	var spec HTMLSpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		return nil, fmt.Errorf("failed to parse spec: %w", err)
	}
	
	return &BuilderGenerator{spec: &spec}, nil
}

// Generate creates all builder API files
func (g *BuilderGenerator) Generate() error {
	// Generate Layer 0 (functional API)
	if err := g.generateFunctionalAPI(); err != nil {
		return fmt.Errorf("failed to generate functional API: %w", err)
	}
	
	// Generate Layer 1 (fluent builder API)
	if err := g.generateBuilderAPI(); err != nil {
		return fmt.Errorf("failed to generate builder API: %w", err)
	}
	
	// Generate props helpers
	if err := g.generateProps(); err != nil {
		return fmt.Errorf("failed to generate props: %w", err)
	}
	
	return nil
}

// generateFunctionalAPI generates the functional layer (Layer 0)
func (g *BuilderGenerator) generateFunctionalAPI() error {
	tmpl := `// Code generated by vango; DO NOT EDIT.

package functional

import (
	"github.com/recera/vango/pkg/vango/vdom"
)

{{ range $category, $elements := .Elements }}
// {{ $category | title }} elements
{{ range $elements }}
{{ if not .Void }}
// {{ .Tag | title }} creates a <{{ .Tag }}> element
func {{ .Tag | title }}(props vdom.Props, children ...*vdom.VNode) *vdom.VNode {
	return vdom.NewElement("{{ .Tag }}", props, children...)
}
{{ else }}
// {{ .Tag | title }} creates a <{{ .Tag }}> element (void/self-closing)
func {{ .Tag | title }}(props vdom.Props) *vdom.VNode {
	return vdom.NewElement("{{ .Tag }}", props)
}
{{ end }}
{{ end }}
{{ end }}

// Text creates a text node
func Text(text string) *vdom.VNode {
	return vdom.NewText(text)
}

// Fragment creates a fragment node
func Fragment(children ...*vdom.VNode) *vdom.VNode {
	return vdom.NewFragment(children...)
}
`

	// Create output directory
	outputDir := filepath.Dir(g.spec.Generation.Layer0.Output)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	
	// Generate code
	funcMap := template.FuncMap{
		"title": strings.Title,
	}
	
	t := template.Must(template.New("functional").Funcs(funcMap).Parse(tmpl))
	var buf bytes.Buffer
	if err := t.Execute(&buf, g.spec); err != nil {
		return err
	}
	
	// Format code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}
	
	// Write file
	return os.WriteFile(g.spec.Generation.Layer0.Output, formatted, 0644)
}

// generateBuilderAPI generates the fluent builder API (Layer 1)
func (g *BuilderGenerator) generateBuilderAPI() error {
	tmpl := `// Code generated by vango; DO NOT EDIT.

package builder

import (
	"github.com/recera/vango/pkg/vango/vdom"
)

// ElementBuilder provides a fluent interface for building VNodes
type ElementBuilder struct {
	tag      string
	props    vdom.Props
	children []*vdom.VNode
	isVoid   bool
}

// newBuilder creates a new element builder
func newBuilder(tag string, isVoid bool) *ElementBuilder {
	return &ElementBuilder{
		tag:      tag,
		props:    make(vdom.Props),
		children: make([]*vdom.VNode, 0),
		isVoid:   isVoid,
	}
}

// Build creates the VNode
func (b *ElementBuilder) Build() *vdom.VNode {
	if b.isVoid {
		return vdom.NewElement(b.tag, b.props)
	}
	return vdom.NewElement(b.tag, b.props, b.children...)
}

// === Common Attributes ===

// ID sets the id attribute
func (b *ElementBuilder) ID(id string) *ElementBuilder {
	b.props["id"] = id
	return b
}

// Class sets the class attribute
func (b *ElementBuilder) Class(class string) *ElementBuilder {
	b.props["class"] = class
	return b
}

// Style sets the style attribute
func (b *ElementBuilder) Style(style string) *ElementBuilder {
	b.props["style"] = style
	return b
}

// Title sets the title attribute
func (b *ElementBuilder) Title(title string) *ElementBuilder {
	b.props["title"] = title
	return b
}

// Hidden sets the hidden attribute
func (b *ElementBuilder) Hidden(hidden bool) *ElementBuilder {
	if hidden {
		b.props["hidden"] = true
	}
	return b
}

// TabIndex sets the tabindex attribute
func (b *ElementBuilder) TabIndex(index int) *ElementBuilder {
	b.props["tabindex"] = index
	return b
}

// === Form Attributes ===

// Disabled sets the disabled attribute
func (b *ElementBuilder) Disabled(disabled bool) *ElementBuilder {
	if disabled {
		b.props["disabled"] = true
	}
	return b
}

// Required sets the required attribute
func (b *ElementBuilder) Required(required bool) *ElementBuilder {
	if required {
		b.props["required"] = true
	}
	return b
}

// Checked sets the checked attribute
func (b *ElementBuilder) Checked(checked bool) *ElementBuilder {
	if checked {
		b.props["checked"] = true
	}
	return b
}

// ReadOnly sets the readonly attribute
func (b *ElementBuilder) ReadOnly(readonly bool) *ElementBuilder {
	if readonly {
		b.props["readonly"] = true
	}
	return b
}

// Name sets the name attribute
func (b *ElementBuilder) Name(name string) *ElementBuilder {
	b.props["name"] = name
	return b
}

// Value sets the value attribute
func (b *ElementBuilder) Value(value string) *ElementBuilder {
	b.props["value"] = value
	return b
}

// Type sets the type attribute
func (b *ElementBuilder) Type(t string) *ElementBuilder {
	b.props["type"] = t
	return b
}

// Placeholder sets the placeholder attribute
func (b *ElementBuilder) Placeholder(placeholder string) *ElementBuilder {
	b.props["placeholder"] = placeholder
	return b
}

// === Link & Media Attributes ===

// Href sets the href attribute
func (b *ElementBuilder) Href(href string) *ElementBuilder {
	b.props["href"] = href
	return b
}

// Src sets the src attribute
func (b *ElementBuilder) Src(src string) *ElementBuilder {
	b.props["src"] = src
	return b
}

// Alt sets the alt attribute
func (b *ElementBuilder) Alt(alt string) *ElementBuilder {
	b.props["alt"] = alt
	return b
}

// Width sets the width attribute
func (b *ElementBuilder) Width(width string) *ElementBuilder {
	b.props["width"] = width
	return b
}

// Height sets the height attribute
func (b *ElementBuilder) Height(height string) *ElementBuilder {
	b.props["height"] = height
	return b
}

// === ARIA Attributes ===

// AriaLabel sets the aria-label attribute
func (b *ElementBuilder) AriaLabel(label string) *ElementBuilder {
	b.props["aria-label"] = label
	return b
}

// AriaHidden sets the aria-hidden attribute
func (b *ElementBuilder) AriaHidden(hidden bool) *ElementBuilder {
	if hidden {
		b.props["aria-hidden"] = "true"
	}
	return b
}

// Role sets the role attribute
func (b *ElementBuilder) Role(role string) *ElementBuilder {
	b.props["role"] = role
	return b
}

// === Event Handlers ===

// OnClick sets the onclick handler
func (b *ElementBuilder) OnClick(handler func()) *ElementBuilder {
	b.props["onclick"] = handler
	return b
}

// OnInput sets the oninput handler
func (b *ElementBuilder) OnInput(handler func(string)) *ElementBuilder {
	b.props["oninput"] = handler
	return b
}

// OnSubmit sets the onsubmit handler
func (b *ElementBuilder) OnSubmit(handler func()) *ElementBuilder {
	b.props["onsubmit"] = handler
	return b
}

// OnChange sets the onchange handler
func (b *ElementBuilder) OnChange(handler func(string)) *ElementBuilder {
	b.props["onchange"] = handler
	return b
}

// === Children ===

// Children adds child nodes
func (b *ElementBuilder) Children(children ...*vdom.VNode) *ElementBuilder {
	if !b.isVoid {
		b.children = append(b.children, children...)
	}
	return b
}

// Text adds a text child
func (b *ElementBuilder) Text(text string) *ElementBuilder {
	if !b.isVoid {
		b.children = append(b.children, vdom.NewText(text))
	}
	return b
}

// === Element Constructors ===

{{ range $category, $elements := .Elements }}
// {{ $category | title }} elements
{{ range $elements }}
// {{ .Tag | title }} creates a <{{ .Tag }}> element builder
func {{ .Tag | title }}() *ElementBuilder {
	return newBuilder("{{ .Tag }}", {{ .Void }})
}
{{ end }}
{{ end }}
`

	// Create output directory
	outputDir := filepath.Dir(g.spec.Generation.Layer1.Output)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	
	// Generate code
	funcMap := template.FuncMap{
		"title": strings.Title,
	}
	
	t := template.Must(template.New("builder").Funcs(funcMap).Parse(tmpl))
	var buf bytes.Buffer
	if err := t.Execute(&buf, g.spec); err != nil {
		return err
	}
	
	// Format code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}
	
	// Write file
	return os.WriteFile(g.spec.Generation.Layer1.Output, formatted, 0644)
}

// generateProps generates prop helper functions
func (g *BuilderGenerator) generateProps() error {
	tmpl := `// Code generated by vango; DO NOT EDIT.

package functional

import (
	"github.com/recera/vango/pkg/vango/vdom"
)

// === Attribute Helpers ===

// Class creates a class property
func Class(class string) vdom.Props {
	return vdom.Props{"class": class}
}

// ID creates an id property
func ID(id string) vdom.Props {
	return vdom.Props{"id": id}
}

// StyleAttr creates a style attribute property
func StyleAttr(style string) vdom.Props {
	return vdom.Props{"style": style}
}

// Href creates an href property
func Href(href string) vdom.Props {
	return vdom.Props{"href": href}
}

// Src creates a src property
func Src(src string) vdom.Props {
	return vdom.Props{"src": src}
}

// Alt creates an alt property
func Alt(alt string) vdom.Props {
	return vdom.Props{"alt": alt}
}

// Type creates a type property
func Type(t string) vdom.Props {
	return vdom.Props{"type": t}
}

// Value creates a value property
func Value(value string) vdom.Props {
	return vdom.Props{"value": value}
}

// Name creates a name property
func Name(name string) vdom.Props {
	return vdom.Props{"name": name}
}

// Placeholder creates a placeholder property
func Placeholder(placeholder string) vdom.Props {
	return vdom.Props{"placeholder": placeholder}
}

// === Boolean Attributes ===

// Disabled creates a disabled property
func Disabled(disabled bool) vdom.Props {
	if disabled {
		return vdom.Props{"disabled": true}
	}
	return vdom.Props{}
}

// Checked creates a checked property
func Checked(checked bool) vdom.Props {
	if checked {
		return vdom.Props{"checked": true}
	}
	return vdom.Props{}
}

// Required creates a required property
func Required(required bool) vdom.Props {
	if required {
		return vdom.Props{"required": true}
	}
	return vdom.Props{}
}

// Hidden creates a hidden property
func Hidden(hidden bool) vdom.Props {
	if hidden {
		return vdom.Props{"hidden": true}
	}
	return vdom.Props{}
}

// ReadOnly creates a readonly property
func ReadOnly(readonly bool) vdom.Props {
	if readonly {
		return vdom.Props{"readonly": true}
	}
	return vdom.Props{}
}

// === Event Handlers ===

// OnClick creates an onclick handler property
func OnClick(handler func()) vdom.Props {
	return vdom.Props{"onclick": handler}
}

// OnInput creates an oninput handler property
func OnInput(handler func(string)) vdom.Props {
	return vdom.Props{"oninput": handler}
}

// OnSubmit creates an onsubmit handler property
func OnSubmit(handler func()) vdom.Props {
	return vdom.Props{"onsubmit": handler}
}

// OnChange creates an onchange handler property
func OnChange(handler func(string)) vdom.Props {
	return vdom.Props{"onchange": handler}
}

// OnFocus creates an onfocus handler property
func OnFocus(handler func()) vdom.Props {
	return vdom.Props{"onfocus": handler}
}

// OnBlur creates an onblur handler property
func OnBlur(handler func()) vdom.Props {
	return vdom.Props{"onblur": handler}
}

// === ARIA Attributes ===

// AriaLabel creates an aria-label property
func AriaLabel(label string) vdom.Props {
	return vdom.Props{"aria-label": label}
}

// AriaHidden creates an aria-hidden property
func AriaHidden(hidden bool) vdom.Props {
	if hidden {
		return vdom.Props{"aria-hidden": "true"}
	}
	return vdom.Props{}
}

// Role creates a role property
func Role(role string) vdom.Props {
	return vdom.Props{"role": role}
}

// === Helper Functions ===

// MergeProps merges multiple prop objects
func MergeProps(props ...vdom.Props) vdom.Props {
	merged := make(vdom.Props)
	for _, p := range props {
		for k, v := range p {
			merged[k] = v
		}
	}
	return merged
}
`

	// Create output directory
	outputDir := filepath.Dir(g.spec.Generation.Props.Output)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}
	
	// Generate code
	t := template.Must(template.New("props").Parse(tmpl))
	var buf bytes.Buffer
	if err := t.Execute(&buf, g.spec); err != nil {
		return err
	}
	
	// Format code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}
	
	// Write file
	return os.WriteFile(g.spec.Generation.Props.Output, formatted, 0644)
}

// Run executes the builder generation
func Run(specPath string) error {
	gen, err := NewBuilderGenerator(specPath)
	if err != nil {
		return err
	}
	
	return gen.Generate()
}