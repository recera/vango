package routes

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ProductionBuilder generates production-ready route code
type ProductionBuilder struct {
	scanner  *Scanner
	routes   []RouteFile
	buildDir string
}

// NewProductionBuilder creates a new production builder
func NewProductionBuilder(routesDir string) (*ProductionBuilder, error) {
	scanner, err := NewScanner(routesDir)
	if err != nil {
		return nil, err
	}

	routes, err := scanner.ScanRoutes()
	if err != nil {
		return nil, err
	}

	// Create build directory
	buildDir := filepath.Join("internal", "generated", "routes")
	if err := os.MkdirAll(buildDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create build directory: %w", err)
	}

	return &ProductionBuilder{
		scanner:  scanner,
		routes:   routes,
		buildDir: buildDir,
	}, nil
}

// Build generates the production route code
func (b *ProductionBuilder) Build() error {
	// Generate main router file
	if err := b.generateRouterFile(); err != nil {
		return fmt.Errorf("failed to generate router file: %w", err)
	}

	// Generate server components file
	if err := b.generateServerComponentsFile(); err != nil {
		return fmt.Errorf("failed to generate server components file: %w", err)
	}

	// Generate route table for client
	if err := b.generateClientRouteTable(); err != nil {
		return fmt.Errorf("failed to generate client route table: %w", err)
	}

	return nil
}

// generateRouterFile generates the main router registration file
func (b *ProductionBuilder) generateRouterFile() error {
	tmplStr := `// Code generated by vango build; DO NOT EDIT.
//go:build !wasm
// +build !wasm

package routes

import (
	"log"
	
	"github.com/recera/vango/pkg/live"
	"github.com/recera/vango/pkg/server"
	"github.com/recera/vango/pkg/vango/vdom"
{{range .Imports}}
	{{.Alias}} "{{.Path}}"
{{end}}
)

// RegisterRoutes registers all application routes
func RegisterRoutes(router *server.Router, liveServer *live.Server, sessionMgr *SessionManager) {
	// Create scheduler bridge for server components
	bridge := live.NewSchedulerBridge(liveServer)
	_ = bridge // Avoid unused warning

{{range .Routes}}
	// Route: {{.URLPattern}}
	{{if .IsAPI}}
	// API route
	router.AddAPIRoute("{{.URLPattern}}", func(ctx server.Ctx) (any, error) {
		// Call the actual API handler
		{{if .NeedsContext}}
		return {{.ImportAlias}}.{{.HandlerName}}(ctx)
		{{else}}
		result := {{.ImportAlias}}.{{.HandlerName}}()
		return result, nil
		{{end}}
	})
	{{else if .HasServer}}
    // Server-driven component
    router.AddRoute("{{.URLPattern}}", func(ctx server.Ctx) (*vdom.VNode, error) {
        // Get session
        sessionID := getSessionID(ctx)
        session, _ := sessionMgr.GetSession(sessionID)
        if session == nil {
            // Create new session if needed
            // This would normally happen in middleware
            log.Printf("Warning: No session for request to %s", ctx.Path())
        }
        // Call server handler
        vnode, err := {{.ImportAlias}}.{{.HandlerName}}(ctx)
        if err != nil { return nil, err }
        // Inject minimal client for server-driven components
        vnode = server.InjectServerDrivenClient(vnode, sessionID)
        return vnode, nil
    })
	{{else}}
	// Universal/client component
	router.AddRoute("{{.URLPattern}}", func(ctx server.Ctx) (*vdom.VNode, error) {
		// Render static component
		{{if .NeedsContext}}
		node := {{.ImportAlias}}.{{.HandlerName}}(ctx)
		{{else}}
		node := {{.ImportAlias}}.{{.HandlerName}}()
		{{end}}
		return &node, nil
	})
	{{end}}
{{end}}

	// Register 404 handler
	router.SetNotFound(handle404)
	
	// Register 500 handler
	router.SetErrorPage(handle500)
	
	log.Printf("âœ… Registered %d routes for production", {{len .Routes}})
}

// handle404 renders the 404 page
func handle404(ctx server.Ctx) (*vdom.VNode, error) {
	ctx.Status(404)
	// Check if custom 404 exists
	{{if .Has404}}
	return routes.Page404(ctx)
	{{else}}
	return defaultNotFound(ctx)
	{{end}}
}

// handle500 renders the 500 error page
func handle500(ctx server.Ctx) (*vdom.VNode, error) {
	ctx.Status(500)
	// Check if custom 500 exists
	{{if .Has500}}
	return routes.Page500(ctx)
	{{else}}
	return defaultError(ctx)
	{{end}}
}

// Helper functions
func getSessionID(ctx server.Ctx) string {
	// Extract session ID from cookie or header
	if cookie, err := ctx.Request().Cookie("vango-session"); err == nil {
		return cookie.Value
	}
	return ""
}

func defaultNotFound(ctx server.Ctx) (*vdom.VNode, error) {
	return &vdom.VNode{
		Kind: vdom.KindElement,
		Tag:  "div",
		Kids: []vdom.VNode{
            {Kind: vdom.KindElement, Tag: "h1", Kids: []vdom.VNode{ {Kind: vdom.KindText, Text: "404 - Not Found"} }},
            {Kind: vdom.KindElement, Tag: "p", Kids: []vdom.VNode{ {Kind: vdom.KindText, Text: "The page you're looking for doesn't exist."} }},
		},
	}, nil
}

func defaultError(ctx server.Ctx) (*vdom.VNode, error) {
	return &vdom.VNode{
		Kind: vdom.KindElement,
		Tag:  "div",
		Kids: []vdom.VNode{
            {Kind: vdom.KindElement, Tag: "h1", Kids: []vdom.VNode{ {Kind: vdom.KindText, Text: "500 - Internal Server Error"} }},
            {Kind: vdom.KindElement, Tag: "p", Kids: []vdom.VNode{ {Kind: vdom.KindText, Text: "Something went wrong. Please try again later."} }},
		},
	}, nil
}
`

	// Prepare template data
	type Import struct {
		Alias string
		Path  string
	}

	type RouteData struct {
		URLPattern   string
		ImportAlias  string
		HandlerName  string
		IsAPI        bool
		HasServer    bool
		NeedsContext bool
	}

	imports := []Import{}
	routeData := []RouteData{}
	importMap := make(map[string]string)
	has404 := false
	has500 := false

	// Process routes
	for i, route := range b.routes {
		// Check for special pages
		if strings.HasSuffix(route.Path, "_404.go") {
			has404 = true
			continue
		}
		if strings.HasSuffix(route.Path, "_500.go") {
			has500 = true
			continue
		}

		// Skip client-only routes
		if route.HasClient && !route.HasServer {
			continue
		}

		// Generate import alias
		alias, exists := importMap[route.ImportPath]
		if !exists {
			if route.Package == "routes" {
				alias = "routes"
			} else {
				alias = fmt.Sprintf("routes%d", i)
			}
			importMap[route.ImportPath] = alias
			imports = append(imports, Import{
				Alias: alias,
				Path:  route.ImportPath,
			})
		}

		// Determine if handler needs context
		needsContext := route.HasServer || route.IsAPI

		routeData = append(routeData, RouteData{
			URLPattern:   route.URLPattern,
			ImportAlias:  alias,
			HandlerName:  route.HandlerName,
			IsAPI:        route.IsAPI,
			HasServer:    route.HasServer,
			NeedsContext: needsContext,
		})
	}

	// Ensure we can call custom pages (404/500) by importing root routes package if present
	if has404 || has500 {
		// Compute root routes import path: <module>/app/routes
		// Prefer using scanner fields to avoid re-reading go.mod
		rootImportPath := strings.ReplaceAll(filepath.Join(b.scanner.moduleName, b.scanner.routesDir), string(filepath.Separator), "/")
		if _, exists := importMap[rootImportPath]; !exists {
			importMap[rootImportPath] = "routes"
			imports = append(imports, Import{Alias: "routes", Path: rootImportPath})
		}
	}

	// Render template
	tmpl, err := template.New("router").Parse(tmplStr)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Imports": imports,
		"Routes":  routeData,
		"Has404":  has404,
		"Has500":  has500,
	})
	if err != nil {
		return err
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, write unformatted for debugging
		formatted = buf.Bytes()
	}

	// Write to file
	outputPath := filepath.Join(b.buildDir, "router_gen.go")
	return os.WriteFile(outputPath, formatted, 0644)
}

// generateServerComponentsFile generates server component registration
func (b *ProductionBuilder) generateServerComponentsFile() error {
	// Filter for server components only
	var serverRoutes []RouteFile
	for _, route := range b.routes {
		if route.HasServer {
			serverRoutes = append(serverRoutes, route)
		}
	}

	if len(serverRoutes) == 0 {
		// No server components, skip
		return nil
	}

	tmplStr := `// Code generated by vango build; DO NOT EDIT.
//go:build !wasm
// +build !wasm

package routes

import (
    "github.com/recera/vango/pkg/server"
    "github.com/recera/vango/pkg/vango/vdom"
{{range .Imports}}
    {{.Alias}} "{{.Path}}"
{{end}}
)

// ServerComponents contains all server-driven component handlers
var ServerComponents = map[string]server.HandlerFunc{
{{range .Routes}}
	"{{.URLPattern}}": {{.HandlerName}}Wrapper,
{{end}}
}

{{range .Routes}}
// {{.HandlerName}}Wrapper wraps the server component
func {{.HandlerName}}Wrapper(ctx server.Ctx) (*vdom.VNode, error) {
	// This wrapper ensures proper context and error handling
	return {{.ImportAlias}}.{{.HandlerName}}(ctx)
}
{{end}}
`

	// Prepare template data
	type Import struct {
		Alias string
		Path  string
	}
	type RouteData struct {
		URLPattern  string
		HandlerName string
		ImportAlias string
	}

	imports := []Import{}
	routeData := []RouteData{}
	importMap := make(map[string]string)
	for i, route := range serverRoutes {
		// Determine alias and collect imports
		alias, exists := importMap[route.ImportPath]
		if !exists {
			if route.Package == "routes" {
				alias = "routes"
			} else {
				alias = fmt.Sprintf("routes%d", i)
			}
			importMap[route.ImportPath] = alias
			imports = append(imports, Import{Alias: alias, Path: route.ImportPath})
		}

		routeData = append(routeData, RouteData{
			URLPattern:  route.URLPattern,
			HandlerName: route.HandlerName,
			ImportAlias: alias,
		})
	}

	// Render template
	tmpl, err := template.New("components").Parse(tmplStr)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Imports": imports,
		"Routes":  routeData,
	})
	if err != nil {
		return err
	}

	// Format and write
	formatted, _ := format.Source(buf.Bytes())
	outputPath := filepath.Join(b.buildDir, "server_components_gen.go")
	return os.WriteFile(outputPath, formatted, 0644)
}

// generateClientRouteTable generates the route table for client-side routing
func (b *ProductionBuilder) generateClientRouteTable() error {
	// Create router/table.json for client-side routing in the same shape dev uses: {"routes": [...]}
	type paramDef struct {
		Name string `json:"name"`
		Type string `json:"type"`
	}
	type routeEntry struct {
		Path       string     `json:"path"`
		Component  string     `json:"component"`
		Params     []paramDef `json:"params,omitempty"`
		Middleware []string   `json:"middleware,omitempty"`
	}
	payload := struct {
		Routes    []routeEntry `json:"routes"`
		Generated bool         `json:"generated"`
	}{Routes: make([]routeEntry, 0), Generated: true}

	for _, route := range b.routes {
		entry := routeEntry{
			Path:      route.URLPattern,
			Component: route.HandlerName,
			Params:    make([]paramDef, 0),
		}
		for _, p := range route.Params {
			// Skip catch-all for param list
			if strings.HasPrefix(p.Name, "...") {
				continue
			}
			entry.Params = append(entry.Params, paramDef{Name: p.Name, Type: p.Type})
		}
		payload.Routes = append(payload.Routes, entry)
	}

	// Marshal to JSON
	data, err := json.MarshalIndent(payload, "", "  ")
	if err != nil {
		return err
	}

	// Ensure router directory exists
	routerDir := "router"
	if err := os.MkdirAll(routerDir, 0755); err != nil {
		return err
	}

	// Write file
	return os.WriteFile(filepath.Join(routerDir, "table.json"), data, 0644)
}

// GenerateProductionServer generates a main.go file for production server
func (b *ProductionBuilder) GenerateProductionServer() error {
	tmplStr := `// Code generated by vango build; DO NOT EDIT.
package main

import (
	"flag"
	"log"
	"net/http"
	"os"

	"github.com/recera/vango/pkg/live"
	"github.com/recera/vango/pkg/server"
	routes "{{.ModulePath}}/internal/generated/routes"
)

func main() {
	// Parse flags
	var (
		port = flag.String("port", getEnv("PORT", "8080"), "Server port")
		host = flag.String("host", getEnv("HOST", "0.0.0.0"), "Server host")
	)
	flag.Parse()

	// Create live server for server-driven components
	liveServer := live.NewServer()

	// Create session manager
	sessionMgr := routes.NewSessionManager(liveServer)
	sessionMgr.StartCleanupRoutine()

	// Create router
	router := server.NewRouter()

	// Register all routes
	routes.RegisterRoutes(router, liveServer, sessionMgr)

    // Create HTTP mux
    mux := http.NewServeMux()

    // WebSocket endpoint for live updates
    mux.HandleFunc("/vango/live/", liveServer.HandleWebSocket)

    // Serve router table for client-side navigation
    mux.HandleFunc("/router/table.json", func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Content-Type", "application/json")
        // Prefer project-level router table if exists
        if data, err := os.ReadFile("router/table.json"); err == nil {
            w.WriteHeader(http.StatusOK)
            _, _ = w.Write(data)
            return
        }
        // Fallback to empty payload
        _, _ = w.Write([]byte("{\"routes\":[]}"))
    })

    // Serve static files
    // Serve built WASM/bootstrap from dist/assets (production build layout)
    mux.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir("dist/assets"))))
    mux.Handle("/public/", http.StripPrefix("/public/", http.FileServer(http.Dir("public"))))
    mux.Handle("/dist/", http.StripPrefix("/dist/", http.FileServer(http.Dir("dist"))))

    // Application routes
    mux.Handle("/", router)

	// Start server
	addr := *host + ":" + *port
    log.Printf("ðŸš€ Production server running at http://%s", addr)
	
	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatal(err)
	}
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
`

	// Get module path from go.mod
	modulePath, err := getModuleName()
	if err != nil {
		return err
	}

	// Render template
	tmpl, err := template.New("main").Parse(tmplStr)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, map[string]interface{}{
		"ModulePath": modulePath,
	})
	if err != nil {
		return err
	}

	// Format and write
	formatted, _ := format.Source(buf.Bytes())
	return os.WriteFile("main_gen.go", formatted, 0644)
}
