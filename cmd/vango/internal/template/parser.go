package template

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"
)

// TemplateParser handles the parsing and code generation for VEX templates
type TemplateParser struct {
	filename        string
	source          string
	packageName     string
	props           *PropsDeclaration
	imports         []string
	templateContent string
	ast             *TemplateAST
}

// PropsDeclaration represents the props struct for a template
type PropsDeclaration struct {
	Fields []PropField
}

// PropField represents a single prop field
type PropField struct {
	Name string
	Type string
}

// NewTemplateParser creates a new template parser
func NewTemplateParser(filename, source string) *TemplateParser {
	return &TemplateParser{
		filename: filename,
		source:   source,
		imports:  []string{},
	}
}

// Parse parses the template source
func (p *TemplateParser) Parse() error {
	// Extract package name
	if err := p.extractPackageName(); err != nil {
		return fmt.Errorf("failed to extract package name: %w", err)
	}

	// Extract props declaration if present
	if err := p.extractProps(); err != nil {
		return fmt.Errorf("failed to extract props: %w", err)
	}

	// Extract template content
	templateContent := p.extractTemplateContent()
	if templateContent == "" {
		return fmt.Errorf("no template content found")
	}
	
	// Store the template content for later parsing
	p.templateContent = templateContent

	return nil
}

// extractPackageName extracts the package name from the source
func (p *TemplateParser) extractPackageName() error {
	packageRe := regexp.MustCompile(`package\s+(\w+)`)
	matches := packageRe.FindStringSubmatch(p.source)
	if len(matches) < 2 {
		return fmt.Errorf("package declaration not found")
	}
	p.packageName = matches[1]
	return nil
}

// extractProps extracts the props declaration
func (p *TemplateParser) extractProps() error {
	propsRe := regexp.MustCompile(`//vango:props\s*\{([^}]*)\}`)
	matches := propsRe.FindStringSubmatch(p.source)

	if len(matches) < 2 {
		// No props declaration, use empty struct
		p.props = &PropsDeclaration{Fields: []PropField{}}
		return nil
	}

	// Parse the props fields
	fieldsStr := matches[1]
	fields := strings.Split(fieldsStr, ";")

	p.props = &PropsDeclaration{Fields: []PropField{}}

	for _, field := range fields {
		field = strings.TrimSpace(field)
		if field == "" {
			continue
		}

		// Parse field name and type
		parts := strings.Fields(field)
		if len(parts) >= 2 {
			p.props.Fields = append(p.props.Fields, PropField{
				Name: parts[0],
				Type: strings.Join(parts[1:], " "),
			})
		}
	}

	return nil
}

// extractTemplateContent extracts the template content after the magic comment
func (p *TemplateParser) extractTemplateContent() string {
	// Find the position of //vango:template
	templateMarker := "//vango:template"
	idx := strings.Index(p.source, templateMarker)
	if idx == -1 {
		return ""
	}
	
	// Skip to the end of the line
	startIdx := idx + len(templateMarker)
	for startIdx < len(p.source) && p.source[startIdx] != '\n' {
		startIdx++
	}
	if startIdx < len(p.source) {
		startIdx++ // Skip the newline
	}
	
	// Skip past package declaration and any directives
	lines := strings.Split(p.source[startIdx:], "\n")
	contentStartIdx := 0
	
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip empty lines, package declarations, imports, and vango directives
		if trimmed == "" || 
		   strings.HasPrefix(trimmed, "package ") || 
		   strings.HasPrefix(trimmed, "import ") ||
		   strings.HasPrefix(trimmed, "//vango:") ||
		   strings.HasPrefix(trimmed, "//") {
			contentStartIdx = i + 1
		} else {
			// Found the start of template content
			break
		}
	}
	
	// Join the remaining lines as template content
	if contentStartIdx < len(lines) {
		return strings.Join(lines[contentStartIdx:], "\n")
	}
	
	return ""
}

// GenerateCode generates Go code from the parsed template
func (p *TemplateParser) GenerateCode() (string, error) {
	// Parse the template content using the VEX parser
	vexParser := NewVexParser(p.filename, p.templateContent)
	ast, err := vexParser.Parse()
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}
	p.ast = ast

	var buf bytes.Buffer

	// Write package declaration
	fmt.Fprintf(&buf, "// Code generated by vango template parser; DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", p.packageName)

	// Write imports
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"fmt\"\n") // For fmt.Sprint in expressions
	fmt.Fprintf(&buf, "\t\"github.com/recera/vango/pkg/vex/builder\"\n")
	fmt.Fprintf(&buf, "\t\"github.com/recera/vango/pkg/vex/functional\"\n")
	fmt.Fprintf(&buf, "\t\"github.com/recera/vango/pkg/server\"\n")
	fmt.Fprintf(&buf, "\t\"github.com/recera/vango/pkg/vango/vdom\"\n")
	for _, imp := range p.imports {
		fmt.Fprintf(&buf, "\t%s\n", imp)
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Write props struct if defined
	if len(p.props.Fields) > 0 {
		fmt.Fprintf(&buf, "// PageProps defines the properties for this template\n")
		fmt.Fprintf(&buf, "type PageProps struct {\n")
		for _, field := range p.props.Fields {
			fmt.Fprintf(&buf, "\t%s %s\n", field.Name, field.Type)
		}
		fmt.Fprintf(&buf, "}\n\n")
	}

	// Write Page function
	fmt.Fprintf(&buf, "// Page renders the template\n")
	if len(p.props.Fields) > 0 {
		fmt.Fprintf(&buf, "func Page(ctx server.Ctx, props PageProps) (*vdom.VNode, error) {\n")
	} else {
		fmt.Fprintf(&buf, "func Page(ctx server.Ctx) (*vdom.VNode, error) {\n")
	}

	// Generate code from AST
	// Check if we have a single simple node that can be returned directly
	if len(p.ast.Nodes) == 1 && !requiresStatements(p.ast.Nodes[0]) {
		// Single simple node - return directly without nodes array
		nodeCode := p.ast.Nodes[0].Generate()
		fmt.Fprintf(&buf, "\treturn %s, nil\n", nodeCode)
	} else {
		// Multiple nodes or complex nodes - use nodes array
		fmt.Fprintf(&buf, "\tvar nodes []vdom.VNode\n\n")
		
		// Generate code for each node
		for _, node := range p.ast.Nodes {
			nodeCode := generateNodeCode(node, 1)
			if nodeCode != "" {
				fmt.Fprintf(&buf, "%s\n", nodeCode)
			}
		}
		
		fmt.Fprintf(&buf, "\n\tif len(nodes) == 1 {\n")
		fmt.Fprintf(&buf, "\t\treturn nodes[0], nil\n")
		fmt.Fprintf(&buf, "\t}\n")
		fmt.Fprintf(&buf, "\treturn builder.Div().Children(nodes...).Build(), nil\n")
	}

	fmt.Fprintf(&buf, "}\n")

	return buf.String(), nil
}

// generateNodeCode generates code for a node with proper indentation and statement handling
func generateNodeCode(node Node, indent int) string {
	// Handle nodes that require statements (if, for)
	switch n := node.(type) {
	case *IfNode:
		return generateIfCode(n, indent)
	case *ForNode:
		return generateForCode(n, indent)
	case *ElementNode:
		// Check if this element has control flow children
		if requiresStatements(n) {
			return generateElementWithControlFlow(n, indent)
		}
		// Simple element - append to nodes array
		indentStr := strings.Repeat("\t", indent)
		nodeCode := n.Generate()
		if nodeCode != "" {
			return fmt.Sprintf("%snodes = append(nodes, %s)", indentStr, nodeCode)
		}
		return ""
	default:
		// Simple nodes - append to nodes array
		indentStr := strings.Repeat("\t", indent)
		nodeCode := node.Generate()
		if nodeCode != "" {
			return fmt.Sprintf("%snodes = append(nodes, %s)", indentStr, nodeCode)
		}
		return ""
	}
}

// requiresStatements checks if a node or its children require statement-level code generation
func requiresStatements(node Node) bool {
	switch n := node.(type) {
	case *IfNode, *ForNode:
		return true
	case *ElementNode:
		// Check if any child requires statements
		for _, child := range n.Children {
			if requiresStatements(child) {
				return true
			}
		}
		return false
	case *ComponentNode:
		// Check if any child requires statements
		for _, child := range n.Children {
			if requiresStatements(child) {
				return true
			}
		}
		return false
	default:
		return false
	}
}

// generateIfCode generates code for an if node
func generateIfCode(n *IfNode, indent int) string {
	var code strings.Builder
	indentStr := strings.Repeat("\t", indent)
	
	// Generate if statement
	code.WriteString(fmt.Sprintf("%sif %s {\n", indentStr, n.Condition))
	
	// Generate then branch
	for _, child := range n.Then {
		childCode := generateNodeCode(child, indent+1)
		if childCode != "" {
			code.WriteString(childCode + "\n")
		}
	}
	
	// Generate else-if branches
	for _, elseIf := range n.ElseIf {
		code.WriteString(fmt.Sprintf("%s} else if %s {\n", indentStr, elseIf.Condition))
		for _, child := range elseIf.Then {
			childCode := generateNodeCode(child, indent+1)
			if childCode != "" {
				code.WriteString(childCode + "\n")
			}
		}
	}
	
	// Generate else branch
	if len(n.Else) > 0 {
		code.WriteString(fmt.Sprintf("%s} else {\n", indentStr))
		for _, child := range n.Else {
			childCode := generateNodeCode(child, indent+1)
			if childCode != "" {
				code.WriteString(childCode + "\n")
			}
		}
	}
	
	code.WriteString(fmt.Sprintf("%s}", indentStr))
	
	return code.String()
}

// generateForCode generates code for a for node
func generateForCode(n *ForNode, indent int) string {
	var code strings.Builder
	indentStr := strings.Repeat("\t", indent)
	
	// Generate for loop
	code.WriteString(fmt.Sprintf("%sfor _, %s := range %s {\n", indentStr, n.Variable, n.Iterator))
	
	// Generate body
	for _, child := range n.Body {
		childCode := generateNodeCode(child, indent+1)
		if childCode != "" {
			code.WriteString(childCode + "\n")
		}
	}
	
	code.WriteString(fmt.Sprintf("%s}", indentStr))
	
	return code.String()
}

// generateElementWithControlFlow generates code for an element that contains control flow children
func generateElementWithControlFlow(n *ElementNode, indent int) string {
	var code strings.Builder
	indentStr := strings.Repeat("\t", indent)
	
	// Create a temporary variable for children
	childrenVar := fmt.Sprintf("children%d", indent)
	code.WriteString(fmt.Sprintf("%svar %s []vdom.VNode\n", indentStr, childrenVar))
	
	// Generate code for each child
	for _, child := range n.Children {
		childCode := generateNodeCodeForChildren(child, indent, childrenVar)
		if childCode != "" {
			code.WriteString(childCode + "\n")
		}
	}
	
	// Build the element with the collected children
	tagMethod := capitalizeFirst(n.Tag)
	code.WriteString(fmt.Sprintf("%snodes = append(nodes, builder.%s()", indentStr, tagMethod))
	
	// Add attributes
	if n.Attributes != nil {
		for name, value := range n.Attributes {
			switch name {
			case "class":
				code.WriteString(fmt.Sprintf(".Class(%q)", value))
			case "id":
				code.WriteString(fmt.Sprintf(".ID(%q)", value))
			case "type":
				code.WriteString(fmt.Sprintf(".Type(%q)", value))
			case "href":
				code.WriteString(fmt.Sprintf(".Href(%q)", value))
			case "src":
				code.WriteString(fmt.Sprintf(".Src(%q)", value))
			default:
				code.WriteString(fmt.Sprintf(".Attr(%q, %q)", name, value))
			}
		}
	}
	
	// Add events
	if n.Events != nil {
		for event, handler := range n.Events {
			switch event {
			case "click":
				code.WriteString(fmt.Sprintf(".OnClick(func() { %s })", handler))
			default:
				code.WriteString(fmt.Sprintf(".On(%q, func() { %s })", event, handler))
			}
		}
	}
	
	// Add the children
	code.WriteString(fmt.Sprintf(".Children(%s...).Build())", childrenVar))
	
	return code.String()
}

// generateNodeCodeForChildren generates code for a node to append to a specific children array
func generateNodeCodeForChildren(node Node, indent int, childrenVar string) string {
	indentStr := strings.Repeat("\t", indent)
	
	switch n := node.(type) {
	case *IfNode:
		return generateIfCodeForChildren(n, indent, childrenVar)
	case *ForNode:
		return generateForCodeForChildren(n, indent, childrenVar)
	default:
		// Simple nodes - append to children array
		nodeCode := node.Generate()
		if nodeCode != "" {
			return fmt.Sprintf("%s%s = append(%s, %s)", indentStr, childrenVar, childrenVar, nodeCode)
		}
		return ""
	}
}

// generateIfCodeForChildren generates an if statement that appends to a children array
func generateIfCodeForChildren(n *IfNode, indent int, childrenVar string) string {
	var code strings.Builder
	indentStr := strings.Repeat("\t", indent)
	
	// Generate if statement
	code.WriteString(fmt.Sprintf("%sif %s {\n", indentStr, n.Condition))
	
	// Generate then branch
	for _, child := range n.Then {
		childCode := generateNodeCodeForChildren(child, indent+1, childrenVar)
		if childCode != "" {
			code.WriteString(childCode + "\n")
		}
	}
	
	// Generate else-if branches
	for _, elseIf := range n.ElseIf {
		code.WriteString(fmt.Sprintf("%s} else if %s {\n", indentStr, elseIf.Condition))
		for _, child := range elseIf.Then {
			childCode := generateNodeCodeForChildren(child, indent+1, childrenVar)
			if childCode != "" {
				code.WriteString(childCode + "\n")
			}
		}
	}
	
	// Generate else branch
	if len(n.Else) > 0 {
		code.WriteString(fmt.Sprintf("%s} else {\n", indentStr))
		for _, child := range n.Else {
			childCode := generateNodeCodeForChildren(child, indent+1, childrenVar)
			if childCode != "" {
				code.WriteString(childCode + "\n")
			}
		}
	}
	
	code.WriteString(fmt.Sprintf("%s}", indentStr))
	
	return code.String()
}

// generateForCodeForChildren generates a for loop that appends to a children array
func generateForCodeForChildren(n *ForNode, indent int, childrenVar string) string {
	var code strings.Builder
	indentStr := strings.Repeat("\t", indent)
	
	// Generate for loop
	code.WriteString(fmt.Sprintf("%sfor _, %s := range %s {\n", indentStr, n.Variable, n.Iterator))
	
	// Generate body
	for _, child := range n.Body {
		childCode := generateNodeCodeForChildren(child, indent+1, childrenVar)
		if childCode != "" {
			code.WriteString(childCode + "\n")
		}
	}
	
	code.WriteString(fmt.Sprintf("%s}", indentStr))
	
	return code.String()
}

// parseTemplate parses the template content and generates VNode code
func (p *TemplateParser) parseTemplate(content string) (string, error) {
	// This is a simplified version - a full implementation would use a proper PEG parser
	// For now, we'll handle basic HTML-like syntax

	// Parse HTML elements - simplified regex without backreference
	elementRe := regexp.MustCompile(`<(\w+)([^>]*)>([^<]*)</(\w+)>`)

	matches := elementRe.FindStringSubmatch(content)
	if len(matches) > 0 {
		openTag := matches[1]
		attrs := matches[2]
		innerContent := matches[3]
		closeTag := matches[4]
		
		// Verify tags match
		if openTag != closeTag {
			return "", fmt.Errorf("mismatched tags: <%s> and </%s>", openTag, closeTag)
		}

		// Parse attributes
		attrMap := p.parseAttributes(attrs)

		// Generate builder code
		var code strings.Builder
		// Capitalize first letter for builder method name
		tagMethod := string(bytes.ToUpper([]byte{openTag[0]})) + openTag[1:]
		code.WriteString(fmt.Sprintf("builder.%s()", tagMethod))

		// Add attributes
		if class, ok := attrMap["class"]; ok {
			code.WriteString(fmt.Sprintf(".Class(%q)", class))
		}
		if id, ok := attrMap["id"]; ok {
			code.WriteString(fmt.Sprintf(".ID(%q)", id))
		}

		// Add text content if present
		if innerContent != "" {
			// Check for template expressions
			if strings.Contains(innerContent, "{{") {
				// Handle template expression
				expr := p.extractExpression(innerContent)
				code.WriteString(fmt.Sprintf(".Text(%s)", expr))
			} else {
				code.WriteString(fmt.Sprintf(".Text(%q)", innerContent))
			}
		}

		code.WriteString(".Build()")
		return code.String(), nil
	}

	// Fallback for plain text
	if strings.Contains(content, "{{") {
		expr := p.extractExpression(content)
		return fmt.Sprintf("functional.Text(%s)", expr), nil
	}

	return fmt.Sprintf("functional.Text(%q)", content), nil
}

// parseAttributes parses HTML attributes
func (p *TemplateParser) parseAttributes(attrs string) map[string]string {
	result := make(map[string]string)

	// Simple attribute parser
	attrRe := regexp.MustCompile(`(\w+)="([^"]*)"`)
	matches := attrRe.FindAllStringSubmatch(attrs, -1)

	for _, match := range matches {
		if len(match) >= 3 {
			result[match[1]] = match[2]
		}
	}

	return result
}

// extractExpression extracts a Go expression from template syntax
func (p *TemplateParser) extractExpression(content string) string {
	// Extract expression from {{.Field}} or {{expr}}
	exprRe := regexp.MustCompile(`\{\{\.?([^}]+)\}\}`)
	matches := exprRe.FindStringSubmatch(content)

	if len(matches) >= 2 {
		expr := strings.TrimSpace(matches[1])
		// If it starts with a capital letter, assume it's a props field
		if len(expr) > 0 && expr[0] >= 'A' && expr[0] <= 'Z' {
			return "props." + expr
		}
		return expr
	}

	return `""`
}
