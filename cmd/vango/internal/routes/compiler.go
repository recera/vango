package routes

import (
	"bytes"
	"fmt"
	"go/format"
	"net/http"
	"net/http/httputil"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"plugin"
	"text/template"

	"github.com/recera/vango/pkg/server"
)

// Compiler compiles routes and provides a handler
type Compiler struct {
	scanner       *Scanner
	routes        []RouteFile
	router        *server.Router
	buildDir      string
	usePlugin     bool               // Use plugin mode (not supported on all platforms)
	useSubprocess bool               // Use subprocess mode (more portable)
	subHandler    *subprocessHandler // active subprocess handler (if any)
}

// NewCompiler creates a new route compiler
func NewCompiler(routesDir string) (*Compiler, error) {
	scanner, err := NewScanner(routesDir)
	if err != nil {
		return nil, err
	}

	// Create build directory for generated code
	buildDir := filepath.Join(".vango", "build", "routes")
	if err := os.MkdirAll(buildDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create build directory: %w", err)
	}

	// Prefer subprocess in dev for hot reload stability across platforms
	return &Compiler{
		scanner:       scanner,
		router:        server.NewRouter(),
		buildDir:      buildDir,
		usePlugin:     false,
		useSubprocess: true,
	}, nil
}

// CompileAll compiles all routes and returns an http.Handler
func (c *Compiler) CompileAll() (http.Handler, error) {
	// Scan for routes
	routes, err := c.scanner.ScanRoutes()
	if err != nil {
		return nil, fmt.Errorf("failed to scan routes: %w", err)
	}

	if len(routes) == 0 {
		// No routes found, return nil handler
		return nil, nil
	}

	c.routes = routes

	// Generate route registration code
	if err := c.generateRouteRegistration(); err != nil {
		return nil, fmt.Errorf("failed to generate route registration: %w", err)
	}

	// Compile based on platform
	if c.usePlugin {
		return c.compileAsPlugin()
	} else if c.useSubprocess {
		return c.compileAsSubprocess()
	} else {
		// Fallback: compile in-process (requires restart for changes)
		return c.compileInProcess()
	}
}

// generateRouteRegistration generates the route registration code
func (c *Compiler) generateRouteRegistration() error {
	tmplStr := `// Code generated by vango dev; DO NOT EDIT.
//go:build vango_server || !vango_client
// +build vango_server !vango_client

package main

import (
    "log"
    "net/http"
    "os"
    
    "github.com/recera/vango/pkg/server"
    {{if .HasPages}}
    vdom "github.com/recera/vango/pkg/vango/vdom"
    {{end}}
{{range .Imports}}
    {{.Alias}} "{{.Path}}"
{{end}}
)

// CreateRouter creates and configures the router with API and SSR/universal page routes (server-driven handled by dev live server)
func CreateRouter() *server.Router {
    router := server.NewRouter()

{{range .Routes}}
    // Route: {{.URLPattern}}
    {{if .IsAPI}}
    router.AddAPIRoute("{{.URLPattern}}", func(ctx server.Ctx) (any, error) {
        {{if .NeedsContext}}
        {{if .ReturnsError}}
        return {{.ImportAlias}}.{{.HandlerName}}(ctx)
        {{else}}
        result := {{.ImportAlias}}.{{.HandlerName}}(ctx)
        return result, nil
        {{end}}
        {{else}}
        {{if .ReturnsError}}
        return {{.ImportAlias}}.{{.HandlerName}}()
        {{else}}
        result := {{.ImportAlias}}.{{.HandlerName}}()
        return result, nil
        {{end}}
        {{end}}
    })
    {{else}}
    // SSR/Universal page route
    router.AddRoute("{{.URLPattern}}", func(ctx server.Ctx) (*vdom.VNode, error) {
        {{if .NeedsContext}}
        {{if .ReturnsError}}
        res, err := {{.ImportAlias}}.{{.HandlerName}}(ctx)
        if err != nil { return nil, err }
        var out *vdom.VNode
        switch v := any(res).(type) {
        case *vdom.VNode:
            out = v
        case vdom.VNode:
            out = &v
        }
        return out, nil
        {{else}}
        res := {{.ImportAlias}}.{{.HandlerName}}(ctx)
        var out *vdom.VNode
        switch v := any(res).(type) {
        case *vdom.VNode:
            out = v
        case vdom.VNode:
            out = &v
        }
        return out, nil
        {{end}}
        {{else}}
        {{if .ReturnsError}}
        res, err := {{.ImportAlias}}.{{.HandlerName}}()
        if err != nil { return nil, err }
        var out *vdom.VNode
        switch v := any(res).(type) {
        case *vdom.VNode:
            out = v
        case vdom.VNode:
            out = &v
        }
        return out, nil
        {{else}}
        res := {{.ImportAlias}}.{{.HandlerName}}()
        var out *vdom.VNode
        switch v := any(res).(type) {
        case *vdom.VNode:
            out = v
        case vdom.VNode:
            out = &v
        }
        return out, nil
        {{end}}
        {{end}}
    })
    {{end}}
{{end}}

    return router
}

// ServeHTTP handles HTTP requests (for plugin mode)
func ServeHTTP(w http.ResponseWriter, r *http.Request) {
    router := CreateRouter()
    router.ServeHTTP(w, r)
}

{{if .UsePlugin}}
// Plugin exports
var Router *server.Router

func init() {
    Router = CreateRouter()
}
{{end}}

{{if .UseMain}}
// Main function for subprocess mode
func main() {
    router := CreateRouter()
    
    port := os.Getenv("VANGO_ROUTE_PORT")
    if port == "" {
        port = "8081"
    }
    
    log.Printf("Route server listening on :%s", port)
    if err := http.ListenAndServe(":"+port, router); err != nil {
        log.Fatal(err)
    }
}
{{end}}
`

	// Prepare template data
	type Import struct {
		Alias string
		Path  string
	}

	type RouteData struct {
		URLPattern   string
		IsAPI        bool
		ImportAlias  string
		HandlerName  string
		NeedsContext bool
		ReturnsError bool
	}

	// Build imports and routes
	imports := []Import{}
	routeData := []RouteData{}
	importMap := make(map[string]string) // path -> alias
	hasPages := false
	// We only generate API wrappers here; reduce imports to only user route packages

	// Process routes and collect imports
	for i, route := range c.routes {
		// Generate for API and SSR/universal page routes.
		// Skip server-driven pages (handled by live handler in dev) and client-only pages.
		// Client-only pages are explicitly marked as HasClient && !HasServer
		if route.HasClient && !route.HasServer {
			// Skip client-only routes
			continue
		}
		// Skip server-driven non-API routes (they're handled by live handler)
		if route.HasServer && !route.IsAPI {
			continue
		}

		// Generate import alias
		alias, exists := importMap[route.ImportPath]
		if !exists {
			if route.Package == "routes" {
				alias = "routes"
			} else {
				alias = fmt.Sprintf("routes%d", i)
			}
			importMap[route.ImportPath] = alias
			imports = append(imports, Import{
				Alias: alias,
				Path:  route.ImportPath,
			})
		}

		// Analyze signature to determine if ctx/err are used
		needsCtx, returnsErr, err := analyzeRouteSignature(route.Path, route.HandlerName)
		if err != nil {
			// Default to needing context and returning error for safety
			needsCtx = true
			returnsErr = true
		}

		rd := RouteData{
			URLPattern:   route.URLPattern,
			IsAPI:        route.IsAPI,
			ImportAlias:  alias,
			HandlerName:  route.HandlerName,
			NeedsContext: needsCtx,
			ReturnsError: returnsErr,
		}
		routeData = append(routeData, rd)
		if !route.IsAPI {
			hasPages = true
		}
	}

	// Render template
	tmpl, err := template.New("routes").Parse(tmplStr)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, map[string]interface{}{
		"Imports":   imports,
		"Routes":    routeData,
		"UsePlugin": c.usePlugin,
		"UseMain":   c.useSubprocess,
		"HasPages":  hasPages,
	})
	if err != nil {
		return err
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, write unformatted for debugging
		fmt.Printf("Warning: failed to format generated code: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file
	outputPath := filepath.Join(c.buildDir, "routes_gen.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	return nil
}

// compileAsPlugin compiles routes as a Go plugin
func (c *Compiler) compileAsPlugin() (http.Handler, error) {
	pluginPath := filepath.Join(c.buildDir, "routes.so")

	// Build the plugin
	cmd := exec.Command("go", "build",
		"-buildmode=plugin",
		"-tags", "vango_server",
		"-o", pluginPath,
		filepath.Join(c.buildDir, "routes_gen.go"),
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to build plugin: %w", err)
	}

	// Load the plugin
	p, err := plugin.Open(pluginPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load plugin: %w", err)
	}

	// Look up the Router variable
	routerSym, err := p.Lookup("Router")
	if err != nil {
		return nil, fmt.Errorf("failed to find Router in plugin: %w", err)
	}

	router, ok := routerSym.(**server.Router)
	if !ok {
		return nil, fmt.Errorf("Router has unexpected type")
	}

	return *router, nil
}

// compileAsSubprocess compiles routes as a separate process
func (c *Compiler) compileAsSubprocess() (http.Handler, error) {
	// For Windows and other platforms that don't support plugins, use a subprocess
	// Stop any existing subprocess first
	if c.subHandler != nil {
		_ = c.subHandler.Stop()
		c.subHandler = nil
	}

	h := &subprocessHandler{
		compiler: c,
	}
	// Start immediately so the handler is ready
	if err := h.startSubprocess(); err != nil {
		return nil, err
	}
	c.subHandler = h
	return h, nil
}

// compileInProcess compiles routes in the current process
func (c *Compiler) compileInProcess() (http.Handler, error) {
	// This is the simplest approach but requires manual route registration
	// For now, we'll return the router with manually registered routes

	// Since we can't dynamically load compiled code without plugins,
	// we'll need to use a different approach or require a restart

	return c.router, nil
}

// subprocessHandler proxies requests to a subprocess
type subprocessHandler struct {
	compiler *Compiler
	process  *exec.Cmd
	port     string
	proxy    http.Handler
}

func (h *subprocessHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Ensure subprocess and proxy are running
	if h.process == nil || h.proxy == nil {
		if err := h.startSubprocess(); err != nil {
			http.Error(w, "route subprocess not available", http.StatusBadGateway)
			return
		}
	}
	h.proxy.ServeHTTP(w, r)
}

func (h *subprocessHandler) startSubprocess() error {
	// Choose a port if not set
	if h.port == "" {
		h.port = "8081"
	}

	// Build the subprocess binary
	binaryPath := filepath.Join(h.compiler.buildDir, "route-server")
	cmd := exec.Command("go", "build",
		"-tags", "vango_server",
		"-o", binaryPath,
		filepath.Join(h.compiler.buildDir, "routes_gen.go"),
	)

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to build subprocess: %w", err)
	}

	// Stop existing if running
	if h.process != nil && h.process.Process != nil {
		_ = h.process.Process.Kill()
		h.process = nil
	}

	// Start the subprocess
	h.process = exec.Command(binaryPath)
	h.process.Env = append(os.Environ(), "VANGO_ROUTE_PORT="+h.port)
	h.process.Stdout = os.Stdout
	h.process.Stderr = os.Stderr

	if err := h.process.Start(); err != nil {
		return err
	}

	// Create reverse proxy
	target, _ := url.Parse("http://127.0.0.1:" + h.port)
	h.proxy = httputil.NewSingleHostReverseProxy(target)
	return nil
}

// Stop terminates the subprocess
func (h *subprocessHandler) Stop() error {
	if h.process != nil && h.process.Process != nil {
		err := h.process.Process.Kill()
		h.process = nil
		return err
	}
	return nil
}

// Recompile recompiles routes after changes
func (c *Compiler) Recompile() (http.Handler, error) {
	return c.CompileAll()
}
